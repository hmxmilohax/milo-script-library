#include ..\config\macros.dta
#include char_face_exp.dta

; these define the facial animation groups that can be used to animate facial expressions
; tied to the animations - they are animated poses

(CharClip
   (editor
      (flags
         bitfield
         (list
            {if_else {== {{$this dir} get_type} ''}
               ()
               {{$this dir} clip_flags}
            }
         ) ; so each charclipset type can show its own flags.
         (help "Band Clip Flags")
      )
   )
)

(CharClipGroup
   (genre
      (genre
         bitfield
         (list ("kGenreRocker" "kGenreDramatic" "kGenreBanger" "kGenreSpazz"))
         (help "flags to determine which genres this clip group is good for")
      )
   )
)

; How long to blend to and from ik within an animation.
#define IK_BLEND_TIME (.5)

(CharClipSamples
   (init
      {if {$this dir}
         {switch {{$this dir} get_type}
            (musician
               {$this set_type musician}
               {$this set blend_width 1}
               {$this set beat_align kPlayBeatAlign1}

               {if {find_elem ("male_guitar" "female_guitar") {{$this dir} name}}
                  {$this set flags {| kValidBass kValidGuitar}}
               }
            )
            (guitarist_strum {$this set flags kPlayAndAttitudeFlags})
            (crowd
               {$this set_type crowd}
               {$this set blend_width 1}
               {$this set beat_align kPlayBeatAlign1}
            )
            (viseme
               {$this set relative {{$this dir} find Base}}
               {$this set blend_width .1}
               {$this set beat_align kPlayRealTime}
               {$this set default_loop kPlayLoop}
               {$this set flags 0}
            )
            (shell
               {$this set_type shell}
               {$this set beat_align kPlayRealTime}
               {$this set blend_width 1}
               {$this set
                  flags
                  {| kLeftArm
                     kRightArm
                     kLeftLeg
                     kRightLeg
                     kDisableLipSync
                     kIgnoreAccent
                     kValidBass
                     kValidGuitar
                  }
               }
            )
         }
      }
   )
   ; go non musicians can have null type
   (allow_null_type
      {if_else {$this dir}
         {!= {{$this dir} get_type} musician}
         1
      }
   )
   (types
      (shell
         (editor
            (viseme_group
               symbol
               (list (CHARVISEMEGROUPS))
               (help "facial mood group for this animation")
            )
            (drum_singlestick bool (help "if drummer shows the separate sticks"))
         )

         (viseme_group normal)
         (drum_singlestick FALSE)

         (enter
            {if [viseme_group]
               {$clip.dude change_face_group [viseme_group]}
            }

            {do
               ($ss [drum_singlestick])
               {with $clip.dude
                  {if {$this exists sticks.grp}
                     {sticks.grp set
                        draw_only
                        {if_else $ss
                           singlestick.grp
                           doublestick.grp
                        }
                     }
                  }
               }
            }
         )

         (event_handlers (CHARVISEMEGROUPS))
      )
      (musician
         (editor
            (viseme_group
               symbol
               (list (CHARVISEMEGROUPS))
               (help "facial mood group for this animation")
            )
         )

         (viseme_group normal)

         (enter
            {if [viseme_group]
               {$clip.dude change_face_group [viseme_group]}
            }
            ; okay this is kind of cheesy.
            {if {== {$clip.dude get_type} vocal}
               {$clip.dude set_instrument
                  {cond
                     ({has_substr {$this name} tambourine} tambourine)
                     ({has_substr {$this name} cowbell} cowbell)
                     ({has_substr {$this name} clap} clap)
                     mic
                  }
               }
            }
         )
         ;; DMS : Commented out to correctly precache
         ;;#ifdef HX_XBOX		; PGM         
         ;;        (exit
         ;;            {with $clip.dude
         ;;               {if {exists left_hand.weight}
         ;;                  {left_hand.weight set beats_per_weight 0}
         ;;               }
         ;;               {if {exists right_hand.weight}
         ;;                  {right_hand.weight set beats_per_weight 0}
         ;;               }
         ;;/*            
         ;;              {if {exists left_foot.weight}
         ;;                  {left_foot.weight set beats_per_weight 0}
         ;;               }
         ;;               {if {exists right_foot.weight}
         ;;                  {right_foot.weight set beats_per_weight 0}
         ;;               }
         ;;*/
         ;;            }
         ;;         )
         ;;#endif				; PGM
         (event_handlers
            ('' ; when inserting one, it will bitch without this.
               freeze
               set_leftarm_true
               set_rightarm_true
               set_leftarm_false
               set_rightarm_false
               CHARVISEMEGROUPS
            )
         )

         CHAR_FACE_FUNCTIONS

         (freeze
            ; placeholder to let the camera find it.  Though maybe it should
            ; actually freeze the character as well.  Think about it.  Would be more
            ; accurate.
         )

         ; Set these flags.
         ;; DMS : Commented out to correctly precache
         ;;#ifdef HX_XBOX		; PGM         
         ;;         (set_leftarm_true
         ;;            {|= [flags] kLeftArm}
         ;;            {$this set_beats_per_weight left_hand.weight}
         ;;         )
         ;;         (set_rightarm_true
         ;;            {|= [flags] kRightArm}
         ;;            {$this set_beats_per_weight right_hand.weight}
         ;;         )
         ;;         (set_leftarm_false
         ;;            {&= [flags] {~ kLeftArm}}
         ;;            {$this set_beats_per_weight left_hand.weight}
         ;;         )
         ;;         (set_rightarm_false
         ;;            {&= [flags] {~ kRightArm}}
         ;;            {$this set_beats_per_weight right_hand.weight}
         ;;         )
         ;;         (set_beats_per_weight ($setter)
         ;;            {do ($weight {find_obj $clip.dude $setter})
         ;;               {if $weight
         ;;                  {$weight set beats_per_weight IK_BLEND_TIME}
         ;;               }
         ;;            }         
         ;;         ) 
         ;;      ) 
         ;;      (crowd
         ;;         (hand clap)
         ;;         (editor
         ;;            (hand symbol (list (clap fist horns)) (help "what the hands should look like"))
         ;;         )
         ;;         (enter
         ;;            ; pick the right hands.
         ;;            {do ($hand [hand])
         ;;               {with $clip.dude
         ;;                  {hands.grp set draw_only 
         ;;                     {switch $hand
         ;;                        (clap clap.grp)
         ;;                        (fist fist.grp)
         ;;                        (horns horns.grp)
         ;;                     }
         ;;                  }
         ;;               }
         ;;            }
         ;;         )
         ;;     )  
         ;;#endif				; PGM         
      )
   )
)

(CharClipSet
   (types
      (viseme
         (version 2)
         (clip_flags ("kExpressionFirst"))
         (compression
            (tolerance .05)
            (bones
               (bone_L-brow1.mesh)
               (bone_L-brow2.mesh)
               (bone_L-brow3.mesh)
               (bone_L-cheek.mesh)
               (bone_L-cheek2.mesh)
               (bone_L-crease.mesh)
               (bone_L-eyelid-low.mesh)
               (bone_L-lid.mesh (offset 1 0 0))
               (bone_L-lipcorner.mesh)
               (bone_L-nose.mesh)
               (bone_R-brow1.mesh)
               (bone_R-brow2.mesh)
               (bone_R-brow3.mesh)
               (bone_R-cheek.mesh)
               (bone_R-cheek2.mesh)
               (bone_R-crease.mesh)
               (bone_R-eyelid-low.mesh)
               (bone_R-lid.mesh (offset 1 0 0))
               (bone_R-lipcorner.mesh)
               (bone_R-nose.mesh)
               (bone_brow-low.mesh)
               (bone_brow-mid.mesh)
               (bone_chin.mesh)
               (bone_forehead.mesh)
               (bone_head.mesh)
               (bone_jaw.mesh)
               (bone_liptop_left.mesh)
               (bone_liptop_mid.mesh)
               (bone_liptop_right.mesh)
               (bone_lowlip_left.mesh)
               (bone_lowlip_mid.mesh)
               (bone_lowlip_right.mesh)
               (bone_neck.mesh)
               (bone_nose.mesh)
               (bone_tongue1.mesh)
               (bone_tongue2.mesh)
               (bone_tongue3.mesh)
               (bone_tongue4.mesh (offset 1 0 0))
               (bone_lowlip_left.mesh)
               (bone_lowlip_right.mesh)
               (bone_lowlip_mid.mesh)
            )
         )
      )

      ; Used for all the full body musician animations.
      (musician
         (version 6)
         (clip_flags
            (
               "kLeftArm"
               "kRightArm"
               "kLeftLeg"
               "kRightLeg"
               "kAnimateEyes"
               "kDisableLipSync"
               "kTempoSlow"
               "kTempoMedium"
               "kTempoFast"
               "kGenreRocker"
               "kGenreDramatic"
               "kGenreBanger"
               "kGenreSpazz"
               "kPlayIdleRealtime"
               "kPlayIdle"
               "kPlayIdleIntense"
               "kPlayMellow"
               "kPlayNormal"
               "kPlayIntense"
               "kPlaySolo"
               "kPlayDirectedCut"
               "kValidGuitar"
               "kValidBass"
               "kIgnoreAccent"
            )
         )

         (filter_clips
            {cond
               ; In game the char_cache deals.
               ({exists char_cache}
                  {if {== {game get_song} ''}
                     {fail "song is null"}
                  }
                  {char_cache filter_clips $this {song_mgr anim_tempo {game get_song}}}
               )
               ; Keep only medium tempo clips chars_file is 
               ; We need to keep all attitudes because of attitude
               ; specific camera shots.
               ({|| $venue_test $char_test $chars_file $first_chars_file_sync}
                  {if_else
                     {&&
                        $chars_file
                        {! $first_chars_file_sync}
                        {has_substr {$this name} "female"}
                     }
                     {do ; Delete them all so we have enough ram.  Will load them during sync.
                        {$this iterate
                           CharClip
                           $clip
                           {unless
                              {find_elem
                                 ("still" "stand_singer_pose" "stand_guitar_pose" "sit_drummer_pose")
                                 {$clip name}
                              }
                              {delete $clip}
                           }
                        }
                     }
                     {do
                        {$this delete_flags kTempoMedium kTempoMedium FALSE 0}
                        {$this delete_variants}
                     }
                  }
               )
            }
         )
         (bone_weights
            (bone_pos_guitar.mesh 0) ; forget the guitar, man!
         )

         (compression
            (tolerance .40)
            (bones
               (bone_R-ankle.mesh (weight .85))
               (bone_L-ankle.mesh (weight .85))
               (bone_R-hand.mesh)
               (bone_L-hand.mesh)
               (bone_R-hand_R-hip.mesh)
               (bone_L-hand_L-hip.mesh)
               (bone_R-hand_mouth.mesh)
               (bone_L-hand_mouth.mesh)
               (bone_L-index03.mesh)
               (bone_L-middlefinger03.mesh)
               (bone_L-ringfinger03.mesh)
               (bone_L-pinky03.mesh)
               (bone_L-thumb03.mesh)
               (bone_R-index03.mesh)
               (bone_R-middlefinger03.mesh)
               (bone_R-ringfinger03.mesh)
               (bone_R-pinky03.mesh)
               (bone_R-thumb03.mesh)
               (bone_head.mesh
                  (weight 1.5)
                  (offset 3 6 0)
               ) ; kind of at the nose.
               (bone_head.mesh
                  (weight 1.5)
                  (offset -2 6 0)
               ) ; kind of at the chin.
            )
         )

         (criteria
            ; no transitions from or to anything realtime.
            (
               (match
                  {||
                     {== {$a_clip get beat_align} kPlayRealTime}
                     {== {$b_clip get beat_align} kPlayRealTime}
                  }
               )
               (cancel)
            )
            (
               ; only match within the same group 
               ; and shares tempo
               ; and shares play flags
               ; and shares genres!
               (match
                  {do
                     ($shared_flags {& {$a_clip get flags} {$b_clip get flags}})
                     {&&
                        {& $shared_flags kTempoAll}
                        {& $shared_flags kPlayDirectedCut}
                        {& $shared_flags kGenreAll}
                        {$a_clip shares_groups $b_clip}
                     }
                  }
               )
               (restrict {&& {< $b_start 1} {< $a_end 2}})
               (beat_align 1)
            )
            (
               (cancel) ; all others goodbye.
            )
         )
      )

      (guitarist_strum
         (version 1)
         (clip_flags
            (
               "kGenreRocker"
               "kGenreDramatic"
               "kGenreBanger"
               "kGenreSpazz"
               "kPlayIdleRealtime"
               "kPlayIdle"
               "kPlayIdleIntense"
               "kPlayMellow"
               "kPlayNormal"
               "kPlayIntense"
               "kPlaySolo"
            )
         )
      )

      (crowd
         (version 1) ; bump this up if any of this state changes, forces all new transitions.      
         (clip_flags ("kTempoSlow" "kTempoMedium" "kTempoFast"))
         (criteria
            (
               (beat_align 1)
               (restrict {&& {< $b_start 1} {< $a_end 2}})
            )
         )
      )

      (shell
         (version 2)
         (clip_flags
            (
               "kLeftArm"
               "kRightArm"
               "kLeftLeg"
               "kRightLeg"
               "kAnimateEyes"
               "kDisableLipSync"
               "kGenreRocker"
               "kGenreDramatic"
               "kGenreBanger"
               "kGenreSpazz"
               "kValidGuitar"
               "kValidBass"
               "kIgnoreAccent"
            )
         )

         (bone_weights
            (bone_pos_guitar.mesh 0) ; forget the guitar, man!
         )

         (compression
            (tolerance .24)
            (bones
               (bone_R-ankle.mesh (weight .85))
               (bone_L-ankle.mesh (weight .85))
               (bone_R-knee.mesh (weight .85))
               (bone_L-knee.mesh (weight .85))
               (bone_R-hand.mesh)
               (bone_L-hand.mesh)
               (bone_R-hand_R-hip.mesh)
               (bone_L-hand_L-hip.mesh)
               (bone_R-hand_mouth.mesh)
               (bone_L-hand_mouth.mesh)
               (bone_L-index03.mesh)
               (bone_L-middlefinger03.mesh)
               (bone_L-ringfinger03.mesh)
               (bone_L-pinky03.mesh)
               (bone_L-thumb03.mesh)
               (bone_R-index03.mesh)
               (bone_R-middlefinger03.mesh)
               (bone_R-ringfinger03.mesh)
               (bone_R-pinky03.mesh)
               (bone_R-thumb03.mesh)
               (bone_head.mesh
                  (weight 1.5)
                  (offset 3 6 0)
               ) ; kind of at the nose.
               (bone_head.mesh
                  (weight 1.5)
                  (offset -2 6 0)
               ) ; kind of at the chin.
            )
         )

         (criteria
            ; no transitions from or to anything realtime.
            (
               (match
                  {||
                     {== {$a_clip get beat_align} kPlayRealTime}
                     {== {$b_clip get beat_align} kPlayRealTime}
                  }
               )
               (cancel)
            )
            (
               ; only match within the same group and if genres share.
               (match
                  {do
                     ($shared_flags {& {$a_clip get flags} {$b_clip get flags}})
                     {&& {& $shared_flags kGenreAll} {$a_clip shares_groups $b_clip}}
                  }
               )
               (restrict {&& {< $b_start 1} {< $a_end 2}})
               (beat_align 1)
            )
            (
               (cancel) ; all others goodbye.
            )
         )
      )
   )
)

(CharCollide
   (editor
      (flags
         bitfield
         (list (CHAR_HAIR_FLAGS))
         (help "Which collision volumes to hook up to this strand for collision")
      )
   )
)

(CharCuff
   (editor
      ; the only categories we care about, pretty sure.
      (category
         symbol
         (list (feet legs torso wrist))
         (help "The outfit category to cuff against")
      )
   )
)

(CharGuitarString
   (types
      (open_strums
         (parser guitar_string_open)
         (enter
            {if [parser]
               {handle ([parser] add_sink $this)}
            }
         )
         (exit
            {if [parser]
               {handle ([parser] remove_sink $this)}
            }
         )

         (open {$this set_open TRUE})

         (closed {$this set_open FALSE})
      )
   )
)

(CharLookAt
   (types
      (guitar_lookat
         (parser guitar_streak_parser)
         (parser2 guitar_singalong_parser)
         (weight 1)

         (enter
            {if [parser]
               {handle ([parser] add_sink $this)}
            }
            {if [parser2]
               {handle ([parser2] add_sink $this)}
            }
         )
         (exit
            {if [parser]
               {handle ([parser] remove_sink $this)}
            }
            {if [parser2]
               {handle ([parser2] add_sink $this)}
            }
         )

         (lookat_in
            {if_else [weight]
               {lookat_in.trig trigger}
               {lookat_out.trig trigger}
            }
         )

         (lookat_out {lookat_out.trig trigger})
      )
      (drum_head
         (enter
            ; need to disable for shell
            {set [weight]
               {if_else {{$this dir} get in_shell}
                  0
                  .8
               }
            }
         )
      )
   )
)

(CharWeightSetter
   (editor
      (flags
         bitfield
         (list
            (
               "kLeftArm"
               "kRightArm"
               "kLeftLeg"
               "kRightLeg"
               "kAnimateEyes"
               "kIgnoreAccent"
               "kDisableLipSync"
            )
         )
         (help "Which Band clip flags to look for")
      )
   )
   (types
      (singalong
         (parser guitar_singalong_parser)
         (editor (parser string (help "name of singalong parser")))
         (enter
            {set [base_weight] 0}
            {handle ([parser] add_sink $this)}
         )
         (exit
            {set [base_weight] 0}
            {handle ([parser] remove_sink $this)}
         )
      )
      ; this ramps up and down a driver with drum hits, so various hits
      ; can allow more or less of the addative animation to play through
      (drummer_play
         (lhand_weight 1)
         (rhand_weight 1)
         (enter
            {set [base_weight] 1}
            {handle (drums_left_hand add_sink $this)}
            {handle (drums_right_hand add_sink $this)}
         )
         (exit
            {set [base_weight] 1}
            {handle (drums_left_hand remove_sink $this)}
            {handle (drums_right_hand remove_sink $this)}
         )

         (get_hand_weight
            ($group)
            {switch $group
               (hihat_fast 0.8)
               (snare_fast 0.5)
               (cymbal_r_grab 0.0)
               (cymbal_l_grab 0.0)
               (cymbal_l_crash 0.5)
               (cymbal_l_crash_big 0.2)
               (cymbal_r_crash 0.5)
               (cymbal_l_crash_fast 0.5)
               (floortom 0.5)
               (floortom_fast 0.5)
               (cymbal_l_side 0.2)
               (cymbal_l_side_fast 0.1)
               (cymbal_r_side 0.2)
               (cymbal_r_side_fast 0.1)
               (ride 0.65)
               (ride_fast 0.45)
               (ride_side_l 0.25)
               (ride_side_r 0.25)
               (cymbal_l 0.5)
               (cymbal_r 0.5)
               (tom_l 0.75)
               (tom_r 0.75)
               (tom_r_fast 0.5)
               (tom_l_fast 0.5)
               1
            }
         )
         (drum_lhand
            ($group $length)
            {set [lhand_weight] {$this get_hand_weight $group}}
            {set [base_weight] {* [lhand_weight] [rhand_weight]}}
         )
         (drum_rhand
            ($group $length)
            {set [rhand_weight] {$this get_hand_weight $group}}
            {set [base_weight] {* [lhand_weight] [rhand_weight]}}
         )
      )
   )
)

#define LIPSERVO_COMMON (
   (change_song {with_file_path_root "." {$this set_blink_song}})

   ; Make us blink!
   (set_blink_song
      {$this set_song "songs/_blinktrack/_blinktrack.voc" TRUE} ; async
      {set [loop] TRUE} ; loop...
      {set [song_offset] {random_float 0 1000}} ; so we don't all blink together.
   )
)

(FaceFxLipSyncServo
   (types
      (singer
         (enter
            ; In the shell we just want to do our own expressions.
            {if_else {{$this dir} get in_shell}
               {do
                  {set [weight_owner] $this}
                  {set [weight] 0}
               }
               {set [weight_owner] expression.weight}
            }
         )
         LIPSERVO_COMMON
      )
      ; This is actually used by the drums as well.
      (guitar
         (enter
            ; For Jason's sing-along.
            {if_else {&& {exists game} {game is_up}}
               {set [song_owner]
                  {find_obj $world player_vocals0 lip.faceservo}
               }
               {set [song_owner] ''}
            }
         )
         LIPSERVO_COMMON
         (exit {set [song_owner] ''})
      )
   )
)

; Include all the instruments.
#include instruments.dta

#define OUTFIT_LOADER_COMMON (
   ; Callback to the game to set my outfit.
   (change_outfit
      ($async $loading)
      {if $loading
         {cond
            #ifndef _SHIP
            ; load time optimization.
            ($char.no_clothes {$this select_all -1})
            #endif
            ({exists char_cache}
               {do
                  ($char_data {char_cache find_char_data {$this dir}})
                  #ifndef _SHIP
                  {unless $char_data
                     {fail "no char_data"}
                  }
                  #endif
                  {$this set_prefab {find {$char_data get_char_data} outfit}}
                  {$this select_instrument $char_data}
               }
            )
            ($venue_test
               {$this select_all -1} ; start out with nothing, sync_mode will load them.
            )
            ; If loading up a venue, hide them all,
            ; the venue will load up the proper outfits
            ; depending on coop or h2h or whatnot.
            ($edit_mode
               {do
                  ($pd {{$this dir} proxy_dir})
                  {if {&& $pd {== {$pd get_type} chars}}
                     {$this select_all -1}
                  }
               }
            )
         }
      }
   )

   (create_path
      ($outfit $cat)
      {cond
         ({&& {== $cat drum} {! {has_substr $outfit "drums_"}}}
            {sprint
               {cond
                  ({&& {exists meta} {meta is_up}} small_club) ; for rock shop
                  ({exists game}
                     {do
                        ($venue {game get_venue_dir})
                        {if_else
                           {||
                              {== $venue blank}
                              {&&
                                 {gamemode get is_hth_arrangement}
                                 {==
                                    {{gamecfg get_player_config {gamecfg get leader_num}} get_track_sym}
                                    drum
                                 }
                              }
                           }
                           small_club
                           $venue
                        }
                     }
                  )
                  ; in milo or wherever
                  ($world
                     {do
                        ($wp {path_name $world})
                        {cond
                           ({has_substr $wp arena} arena)
                           ({has_substr $wp big_club} big_club)
                           ({has_substr $wp small_club} small_club)
                           ({has_substr $wp theater} theater)
                           small_club
                        }
                     }
                  )
                  small_club ; default...
               }
               "_drums_"
               $outfit
            }
         )
         ({&& {|| {== $cat guitar} {== $cat bass}} 
              {! {has_substr $outfit "_"}}}
            {sprint
               $outfit
               "_"
               {if_else {exists game}
                  ; in the game, ask the character what variant we should have
                  {{char_cache find_char_data {$this dir}} selected_variant $cat $outfit}
                  ; everywhere else, find the default variant
                  {elem
                     {find
                        $syscfg
                        objects
                        OutfitLoader
                        types
                        male
                        category
                        $cat
                        outfits
                        $outfit
                        default_variant
                     }
                     1
                  }
               }
            }
         )
         (TRUE kDataUnhandled)
      }
   )

   (select_instrument
      ($char_data)
      ; don't load any instruments, will load later when entering
      ; venue or the instrument shop
      {switch {$char_data get_instrument}
         ; just keep our mic loaded
         (drum
            ; don't load a drum in the shell
            {$this wipe_instruments}
         )
         (guitar
            {$this select guitar {$char_data selected_outfit guitar}}
            ; don't show a bass unless we're in the bass instrument shop
            {$this select bass none}
         )
      }
   )

   (wipe_instruments
      {foreach $inst (INSTRUMENTS)
         {$this select {elem $inst 0} none}
      }
   )
)

(OutfitLoader
   #include outfitloader.dta
)

#define DEFORM_COMMON (
   (deform
      ; this checks to see if the CharClipSet is proxied in.
      {if {$this exists deform_clips}
         {do
            ($clip {deform_clips find deform})
            ; Prepare for the process.
            {start_char_utl_deform}
            ; First set to the zero pose and capture.
            {char_utl_deform $this $clip ((0 1)) FALSE}
            {$this iterate CharIKScale $s {$s capture_before}}

            {char_utl_deform
               $this
               $clip
               (
                  (0 {$this deform_frame 0})
                  (1 {$this deform_frame 1})
                  (2 {$this deform_frame 2})
                  (3 {$this deform_frame 3})
                  (4 {$this deform_frame 4})
               )
               TRUE
            }

            {end_char_utl_deform} ; sync the meshes.

            {$this iterate CharIKScale $s {$s capture_after}}
            {$this iterate CharIKHand $s {$s measure_lengths}}
            {$this iterate CharForeTwist $s {$s measure_length_scale}}

            /*         
            ; Show the delta between world z of hand and hip target (for adolph)
            ; @TEST
            {do ($a) ($b) ($hand) ($hip)
               {bone_R-hand.mesh get_world_pos $a $b $hand}
               {bone_target_R-hip.mesh get_world_pos $a $b $hip}
               {print "delta z hand and hip is " {- $hand $hip} "\n"}
               {print "relative to hand_base is " {- $hand_base {- $hand $hip}} "\n"}
            }
   */
         }
      }
   )
)

#define PRE_META_CONFIGURE_COMMON (
   {set [in_shell] TRUE} ; we're being put into the shell

   ; High concept is to clear everything
   {$this iterate
      FaceFxLipSyncServo
      $servo
      {$servo set_song "" TRUE}
   }

   ; wipe out instruments right now to reduce fragmentation.
   {OutfitLoader.outfit wipe_instruments}
   {OutfitLoader.outfit start_load FALSE}

   ; clear our clips!
   {main.drv set_clips ''}
)

#define META_CONFIGURE_COMMON (
   ; set our clips!
   {main.drv set_clips {char_cache get_shell_clips $this}}

   ; Blink curse you, blink!   
   {$this set_blink_song}

   ; select appropriate instrument for shell
   ; we do this here to try to avoid fragmentation.
   {do
      ($char_data {char_cache find_char_data $this})
      {OutfitLoader.outfit select_instrument $char_data}
      {OutfitLoader.outfit start_load TRUE}
   }
)

;; Characters.

#define CHAR_COMMON (
   (in_shell FALSE) ; used to load/configure differently when in game and shell
   (playing TRUE) ; am I playing right now, ie, not BFB or h2h alternating.
   (cur_play 0) ; playing mode I should be in were i playing
   (old_pelvis_scale 1) ; saved off value used for sitting camera shots.

   (editor
      (height
         float
         (help "Deformation height 0-1")
         (range 0 1)
         (post_sync {$this deform})
      )
      (weight
         float
         (help "Deformation weight 0-1")
         (range 0 1)
         (post_sync {$this deform})
      )
      (neutral
         script
         (help "Sets h=.5 w=.5")
         (script
            {set [height] .5}
            {set [weight] .5}
            {$this deform}
         )
         (refresh height weight)
      )
      (tall_and_fat
         script
         (help "Sets h=1 w=1")
         (script
            {set [height] 1}
            {set [weight] 1}
            {$this deform}
         )
         (refresh height weight)
      )
      (short_and_fat
         script
         (help "Sets h=0 w=1")
         (script
            {set [height] 0}
            {set [weight] 1}
            {$this deform}
         )
         (refresh height weight)
      )
      (tall_and_skinny
         script
         (help "Sets h=1 w=0")
         (script
            {set [height] 1}
            {set [weight] 0}
            {$this deform}
         )
         (refresh height weight)
      )
      (short_and_skinny
         script
         (help "Sets h=0 w=0")
         (script
            {set [height] 0}
            {set [weight] 0}
            {$this deform}
         )
         (refresh height weight)
      )
      (strum_and_fret
         script
         (help "Makes the character strum and fret so the arms aren't all wacky")
         (script
            {if {exists strum.dmidi}
               {strum.dmidi play 0 kPlayGraphLoop}
            }
            {if {exists fret.dmidi}
               {fret.dmidi play 0 kPlayGraphLoop}
            }
         )
      )
      (face_expression_test_group
         symbol
         (list (CHARVISEMEGROUPS))
         (help "test group")
      )
      (face_expression_test
         script
         (script
            {set $clipset {expression.drv get clips_ptr}}
            {set $grp {$clipset find [face_expression_test_group]}}
            {expression.drv play_group {$grp name}}
         )
      )
      (become_bass
         script
         (script
            {$this exit}
            {$this load_instrument bass}
            {$this world_configure bass}
            {$this enter}
            {if {exists strum.dmidi}
               {strum.dmidi play 0 kPlayGraphLoop}
            }
            {if {exists fret.dmidi}
               {fret.dmidi play 0 kPlayGraphLoop}
            }
            {main.drv play stand_guitar_pose}
         )
         (help "become a bassist")
      )
      (become_guitar
         script
         (script
            {$this exit}
            {$this load_instrument guitar}
            {$this world_configure guitar}
            {$this enter}
            {if {exists strum.dmidi}
               {strum.dmidi play 0 kPlayGraphLoop}
            }
            {if {exists fret.dmidi}
               {fret.dmidi play 0 kPlayGraphLoop}
            }
            {main.drv play stand_guitar_pose}
         )
         (help "become a guitarist")
      )

      ; Load win final animations.
      (load_win_final
         script
         (script {$this load_win_finals})
         (help
            "load up the win_final animations.  Only do one at a time if possible, they are big!"
         )
      )

      (unload_win_final
         script
         (script
            {do
               ($clips {main.drv get_clips})
               {main.drv enter}
               {do
                  {$clips iterate_self
                     CharClip
                     $clip
                     {if {has_substr {$clip name} win_final}
                        {delete $clip}
                     }
                  }
               }
            }
         )
         (help "unload the win final animations")
      )
   )
   (face_expression_test_group normal)

   ; deform properties
   (height 0.5 proxy_save)
   (weight 0.5 proxy_save)

   (freeze_char
      ($freeze $unfreeze $units)
      ; back up the animation until it's back from the event called freeze
      {script_task $units (delay $freeze) (script {$this freeze})}
      {script_task
         $units
         (delay {+ $freeze $unfreeze})
         (script {$this unfreeze})
      }
   )

   ; this gets called when you change the properties in milo.
   (change_char_config
      {do
         ($char_data 0)
         {if {exists char_cache}
            {set $char_data {char_cache find_char_data $this}}
            #ifndef _SHIP
            {unless $char_data
               {notify "no char_data"}
            }
            #endif
            {if $char_data
               {$char_data configure_char $this}
            }
         }
         ; apply the deformation to our loaded guy.
         {$this deform}
      }

      ; the UI might want to update now that we're loaded
      {handle (ui change_char_config)}
   )

   (idle_realtime {$this change_play kPlayIdleRealtime})

   (idle {$this change_play kPlayIdle})

   (idle_intense {$this change_play kPlayIdleIntense})

   (mellow {$this change_play kPlayMellow})

   (play {$this change_play kPlayNormal})

   (intense {$this change_play kPlayIntense})

   (play_solo {$this change_play kPlaySolo})

   (change_play
      ($mode)
      {set [cur_play] $mode}
      ; not playing remap the mode to an idle of similar intensity.
      {unless [playing]
         {switch $mode
            (
               (kPlayIntense kPlaySolo)
               {set $mode kPlayIdleIntense}
            )
            (
               (kPlayMellow kPlayNormal)
               {set $mode kPlayIdle}
            )
         }
      }

      {$this set_play $mode}
   )

   (tambourine_start {$this group_override tambourine})

   (tambourine_end {$this group_override ''})

   (cowbell_start {$this group_override cowbell})

   (cowbell_end {$this group_override ''})

   (clap_start {$this group_override clap})

   (clap_end {$this group_override ''})

   (game_over
      {handle ([parser] remove_sink $this)}

      {$this group_override ''}

      {$this iterate CharIKMidi $midi {handle ($midi game_over)}}
      {$this iterate CharDriverMidi $midi {handle ($midi game_over)}}
   )

   ; Just before we play the new cam, force us to realtime
   ; this is mostly for band world tour so we can dump animations
   ; later.
   (playing_final_cam {$this idle_realtime})

   (game_outro
      {if {exists game}
         {{$this dir} remove_sink $this}
      }
   )

   (terminate)

   (change_proxies
      ; set property indicating whether we're in shell, based on our proxy_dir
      ; we only get loaded by the game, and that's in the shell, so we're shell
      {do
         ($pd {$this proxy_dir})
         {set [in_shell] {|| {&& $pd {== {$pd get_type} shell}} {exists game}}}
      }
   )

   ; Called each time the loader finishes loading.
   ; need to re-hook up the hair.
   (sync_objects
      {$this iterate CharHair $hair {$hair hookup}}
      {do
         ($visemes
            {if_else {$this exists visemes}
               {$this find visemes}
               ; this could come up in Milo where they have no head at all.  Poor things.
               {do
                  ($vis '')
                  /* TODO fix this!!!              
                  {if {exists game}
                     {notify "hey " $this " loading viseme 1 in game!"}
                  }
*/
                  {with_file_path_root
                     "."
                     {set $vis {load_objects "char/male/anim/male_viseme_head_1.milo"}}
                  }
                  {$vis delete_loader}
                  $vis
               }
            }
         )
         ; Visemes is proxied into the heads, so we have to hand-set these each time.
         {handle
            (lip.faceservo set clips_ptr $visemes)
         }
         {handle (expression.drv set_clips $visemes)}
         {handle (face_accent.dmidi set_clips $visemes)}
      }
   )

   ; should we split the clips up.
   (split_clips {|| $cache_mode $char.split_clips})

   ; Our song tempo.  Returns 0 if not splitting clips.
   (song_tempo
      {if_else {$this split_clips}
         {song_mgr anim_tempo {game get_song}}
         0
      }
   )

   (world_configure_driver
      ($driver $suffix)
      {if {$this split_clips}
         {char_cache add_world_clips_loader $this $suffix kTempoAll}
      }
      {char_cache add_world_clips_loader $this $suffix {$this song_tempo}}
      ; And kill off the clips that are there now, so we keep our high water mark smaller
      {$driver set_clips ''}
   )

   (world_set_driver
      ($driver $suffix)
      {if_else {$this split_clips}
         {do
            {$driver set_clips
               {char_cache get_world_clips $this $suffix kTempoAll}
            }
            {do
               ($clips {char_cache get_world_clips $this $suffix {$this song_tempo}})
               ; clips may not be there because of shared bass and guitar, if same attitude.
               ; this is okay.
               {if $clips
                  {reserve_to_fit $clips {$driver get_clips} 0}
                  {merge_dirs $clips {$driver get_clips} kMergeMerge}
                  {delete $clips}
               }
            }
         }
         {$driver set_clips
            {char_cache get_world_clips $this $suffix 0}
         }
      }
   )

   (prep_multi_driver
      ($driver $suffix)
      {do
         ($clips {$driver get_clips})
         {$clips delete_loader}
         ; delete all animations that are not all tempos, 
         ; which should mean what we are playing now is still fine.
         {$clips delete_flags kTempoAll kTempoAll FALSE 0}
      }
      {char_cache add_world_clips_loader $this $suffix {$this song_tempo}}
   )

   (enter_multi_driver
      ($driver $suffix)
      {do
         ($clips {char_cache get_world_clips $this $suffix {$this song_tempo}})
         ; clips may not be there since we may have shared bass and guitar
         {if $clips
            ; kill the all tempo clips.  We already have them.
            ; TODO we should do this from C too in CharCache since we get a filtering callback.
            {$clips delete_flags kTempoAll kTempoAll TRUE 0}
            {reserve_to_fit $clips {$driver get_clips} 0}
            {merge_dirs $clips {$driver get_clips} kMergeMerge}
            {delete $clips}
         }
      }
   )

   (set_blink_song
      {$this iterate FaceFxLipSyncServo $servo {$servo set_blink_song}}
   )

   (disable_pelvis_ik
      {set [old_pelvis_scale] {pelvis.ikscale get scale}}
      {pelvis.ikscale set scale 1}
   )

   (enable_pelvis_ik {pelvis.ikscale set scale [old_pelvis_scale]})

   ; return the path to win final animations.
   (win_final_path
      {if_else {&& {$this split_clips} {exists char_cache}}
         ; split is genre specific.
         {sprint
            "char/"
            [gender]
            "/anim/"
            [gender]
            "_"
            {$this get_type}
            "_win_final_"
            {char_cache attitude_string [attitude]}
            ".milo"
         }
         {sprint
            "char/"
            [gender]
            "/anim/"
            [gender]
            "_"
            {$this get_type}
            "_win_final.milo"
         }
      }
   )

   (win_final_start_load
      {do
         ($clips {main.drv get_clips})

         {main.drv enter} ; reset the state just in case.

         ; Kill all beat based animations, the beat is over.
         ; do so by setting flags.
         {do
            {{$clips find win} set_flags kSaveMe} ; in this case means "save me"
            {{$clips find realtime_idle} set_flags kSaveMe}
            {if {$clips exists still}
               {with {$clips find still}
                  {|= [flags] kSaveMe}
               }
            }
            {$clips delete_flags kSaveMe kSaveMe FALSE 0}
         }

         ; Add the loader.
         {char_cache add_world_clips_loader
            $this
            _win_final
            {if_else {$this split_clips}
               -1
               0
            }
         }
      }
   )

   ; are the win finals loaded?
   (win_final_loaded
      ; TODO this might be too slow...  Maybe need a property
      ; on Clips instead, that merging would set true.
      {do
         ($ret FALSE)
         ($clips {main.drv get_clips})
         {$clips iterate_self
            CharClip
            $clip
            {if {has_substr {$clip name} win_final}
               {set $ret TRUE}
            }
         }
         $ret
      }
   )

   ; check to see if it's loaded yet,
   ; if it is, return TRUE
   (win_final_check_load
      {if_else {$this win_final_loaded}
         TRUE
         {do
            ($wins
               {char_cache get_world_clips
                  $this
                  _win_final
                  {if_else {$this split_clips}
                     -1
                     0
                  }
               }
            )
            {if_else $wins
               {do
                  ($clips {main.drv get_clips})
                  {reserve_to_fit $wins $clips 0}
                  {merge_dirs $wins $clips kMergeMerge}
                  {delete $wins}
                  TRUE
               }
               FALSE
            }
         }
      }
   )

   ; synchronous load of win finals.
   (load_win_finals
      {do
         ($clips {main.drv get_clips})
         {main.drv enter}
         {do
            ($wins '')
            {with_file_path_root "." {set $wins {load_objects {$this win_final_path}}}}
            {reserve_to_fit $wins $clips 0}
            {merge_dirs $wins $clips kMergeMerge}
            {delete $wins}
         }
      }
   )

   DEFORM_COMMON
)

#define CHAR_ENTER_COMMON (
   {set $is_proxy {&& {! {exists game}} {$this is_proxy}}}
   {set [playing] TRUE}
   {set [cur_play] 0}

   {if_else {exists game}
      ; If actually in the game.   
      {if {game is_up}
         {handle ([parser] add_sink $this)}
         {{$this dir} add_sinks $this game_over game_outro playing_final_cam}

         ; So we know when we hit and miss and all that.
         {if {exists char_cache}
            {do
               ($player {game get_player {char_cache find_index $this}})
               {if $player
                  {$player add_sinks $this hit miss pass disable_player enable_player}
               }
            }
         }

         ; Randomize these suckers!  Or do it when it comes time
         ; to filter the clips, so we chuck out bad ones.
         {$this iterate
            CharDriver
            $driver
            {do
               ($clips {$driver get clips_ptr})
               {if $clips
                  {$clips randomize_groups}
               }
            }
         }

         ; If separate parts then see if we will register with the alternating things.
         {if {gamemode get separate_parts}
            {do
               ($desired_name
                  {switch $game.play_mode
                     (h2h_drum drum)
                     (h2h_guitar guitar)
                     (h2h_bass bass)
                     (h2h_vocals vocal)
                     ''
                  }
               )
               {if {&& $desired_name {has_substr {$this name} $desired_name}}
                  {if_else {== {game get_player_num_from_slot_num 0} {char_cache find_index $this}}
                     {slot0_enable add_sink $this}
                     {slot1_enable add_sink $this}
                  }
                  {$this disable_player} ; start out disabled.
               }
            }
         }

         {$this set_play kPlayIdleRealtime}
         {$this change_group [start_group]}
      }

      ; Not in the app at all.
      {do
         {set [attitude] 0} ; stomp out attitude so it uses all clips it can.
         {cond
            ($venue_test {eval 0}) ; do nothing.
            ([in_shell]
               {eval 0}
            ) ; for starters, nothing, they can set something on a camera
            ($is_proxy {$this change_group [pose_group]})
         }

         ; We ONLY want to do any of this if not in game at all!
         {cond
            ; if in chartest, venuetest, or milo with them proxied in, set to neutral
            ; and bake them in.
            ({|| $char_test $venue_test $is_proxy}
               {set [weight] .5}
               {set [height] .5}
               {$this deform}
            )
            ; default, so we either deform or reset the saved out scales to one.
            ; kind of silly, but there you go.
            {$this iterate
               CharIKScale
               $s
               {$s set scale 1}
            }
            {$this iterate
               CharForeTwist
               $s
               {$s set length_scale .38}
            }
         }
      }
   }
)

(CharDriver
   (types
      ; used by the main driver, they should all be set this way.
      (main
         (change_clips
            {cond
               ({exists char_cache}
                  {with_file_path_root
                     "."
                     {$this set_clips_path {char_cache get_shell_clips_path {$this dir}}}
                  }
               )
               ({&& {{$this dir} proxy_dir} {== {{{$this dir} proxy_dir} get_type} shell}}
                  {do
                     ($gender
                        {if_else {has_substr {{$this dir} name} female}
                           female
                           male
                        }
                     )
                     ($instrument {{$this dir} get_type})
                     ($path {sprint "anim/" $gender "_" $instrument "_shell.milo"})
                     {$this set clips $path}
                  }
               )
            }
         )
      )
      (expression)
      (drum_add
         (change_clips
            ; load up nothing when in shell.
            {if {{$this dir} get in_shell}
               {$this set_clips_path ""}
            }
         )
      )
   )
)

(CharDriverMidi
   (types
      (musician
         (parser bass_fret)
         (editor (parser symbol (help "Name of the midi parser to hook into")))
         (enter
            {if_else {exists [parser]}
               {do
                  {[parser] add_sink $this}
                  {if {[parser] idle}
                     {do
                        ($idle {[parser] get idle_message})
                        ($thing {[clips_ptr] find $idle})
                        ; Thing can be a group or a clip.
                        {set [inactive_clip]
                           {if_else {$thing is_a CharClipGroup}
                              {$thing find_clip 0} ; finds first thing in it, TODO could look up attitude if needed.
                              $thing
                           }
                        }
                        {$this play [inactive_clip]}
                     }
                  }
               }
               ; Parser does not exist.
               {do
                  ($scene {{$this dir} dir})
                  {unless {== {$scene get_type} shell}
                     ; If in chartest or venuetest or in edit_mode and my parent is not his own dir (ie, he's in a venue..)
                     {if {|| $venue_test $char_test {&& $edit_mode {!= $scene {$this dir}}}}
                        {$this play 0 kPlayGraphLoop} ; play anything, int 0 is flag that matches all.
                     }
                  }
               }
            }
         )
         (exit {handle ([parser] remove_sink $this)})
         (game_over {handle ([parser] remove_sink $this)})
         (drum_lhand
            ($group $length)
            {$this strum $group $length}
         )
         (drum_rhand
            ($group $length)
            {$this strum $group $length}
         )

         (strum
            ($group $length)
            {do
               ($flags {& {{$this dir} get_play_flags} kPlayAndAttitudeFlags})
               ($group {[clips_ptr] find $group})
               ($clip {$group find_clip $flags})

               ; TODO remove before ship, this is to prevent crashes if no match.  CDB finds these.
               {unless $clip
                  {print
                     "NOTIFY: "
                     {path_name $group}
                     " could not find clip with flags "
                     $flags
                     ", trying 0\n"
                  }
                  {set $clip {$group get_clip}}
               }

               ; TODO remove before ship
               {if_else $clip
                  {do
                     {if {== {$clip get beat_align} kPlayRealTime}
                        {set $length {$mp.parser beat_to_sec_length $length}}
                     }
                     {$this midi_parser $clip $length}
                  }
                  {print "NOTIFY: " {path_name $group} " could find no clip\n"}
               }
            }
         )
      )
   )
)

(CharHair
   (editor
      (strands
         (array
            (struct
               (hookup_flags
                  bitfield
                  (list (CHAR_HAIR_FLAGS))
                  (help "Which collision volumes to hook up to this strand for collision")
               )
            )
         )
      )
   )
)

(CharIKMidi
   (types
      (musician
         (parser guitar_fret_pos)
         (editor (parser symbol (help "Name of the midi parser to hook into")))
         (enter
            {if {exists [parser]}
               {[parser] add_sink $this}
            }
         )
         (exit {handle ([parser] remove_sink $this)})
         (game_over {handle ([parser] remove_sink $this)})
      )
   )
)

; These are things that have to be enabled/disabled during h2h play
#define GUITAR_THINGS (
   (face_accent.dmidi
      fret.dmidi
      strum.dmidi
      fret.ikmidi
      string_hi.dmidi
      string_low.dmidi
      guitar.lookat
   )
)

#define DRUM_THINGS (
   (hihat.dmidi
      kick.dmidi
      left_crash.dmidi
      left_foot.dmidi
      left_hand.dmidi
      ride.dmidi
      right_crash.dmidi
      right_foot.dmidi
      right_hand.dmidi
   )
)

(CompositeCharacter
   (types
      (guitar
         (clip_flags kValidGuitar)
         (start_group stand)
         (pose_group stand_pose)
         (parser guitarist_parser)
         (instrument guitar)

         (enable_player
            {foreach $thing GUITAR_THINGS
               {handle ({$thing get parser} add_sink $thing)} ; some parsers could be null.
            }
            {set [playing] TRUE}
            {$this change_play [cur_play]}
         )

         (disable_player
            {foreach $thing GUITAR_THINGS
               {handle ({$thing get parser} remove_sink $thing)} ; some parsers could be null.
            }
            {set [playing] FALSE}
            {$this change_play [cur_play]}
         )
         ;; DMS : Commented out to correctly precache         
         ;;#ifdef HX_XBOX		; PGM
         ;;         (enter         
         ;;            CHAR_ENTER_COMMON
         ;;            ; Always start with your hands off of the guitar.
         ;;            {left_hand.weight set beats_per_weight 0}
         ;;            {right_hand.weight set beats_per_weight 0}
         ;;           {left_hand.weight set weight 0}
         ;;            {right_hand.weight set weight 0}
         ;;         )
         ;;#endif				; PGM

         ; Set the instrument for this guy based on the track type.
         (load_instrument
            ($track_type)
            {do
               ($char_data
                  {if_else {exists char_cache}
                     {char_cache find_char_data $this}
                     0
                  }
               )
               {if_else {== $track_type guitar}
                  {do
                     {OutfitLoader.outfit select
                        guitar
                        {if_else $char_data
                           {$char_data selected_outfit $track_type}
                           {$this valid_instrument $track_type}
                        }
                     }
                     {OutfitLoader.outfit select bass none}
                  }
                  {do
                     {OutfitLoader.outfit select
                        bass
                        {if_else $char_data
                           {$char_data selected_outfit $track_type}
                           {$this valid_instrument $track_type}
                        }
                     }
                     {OutfitLoader.outfit select guitar none}
                  }
               }
            }
            {OutfitLoader.outfit start_load TRUE}
         )

         (pre_meta_configure PRE_META_CONFIGURE_COMMON)

         (meta_configure META_CONFIGURE_COMMON)

         ; takes bass or guitar, must be called before "enter"
         ; to work in game.
         (world_configure
            ($t)

            {set [in_shell] FALSE} ; we're being put into game, not shell
            {$this set_blink_song}
            {if_else {== $t guitar}
               {do
                  {string01.string set parser guitar_string_open}
                  {string02.string set parser guitar_string_open}
                  {string03.string set parser guitar_string_open}
                  {string04.string set parser guitar_string_open}
                  {string05.string set parser guitar_string_open}
                  {string06.string set parser guitar_string_open}
                  {guitar.lookat set parser guitar_streak_parser}
                  {set [clip_flags] kValidGuitar}
                  {set [parser] guitarist_parser}
                  {fret.dmidi set parser guitar_fret}
                  {strum.dmidi set parser guitar_strum}
                  {face_accent.dmidi set parser guitar_face_accent}
                  {fret.ikmidi set parser guitar_fret_pos}
                  {singalong.weight set parser guitar_singalong_parser}
                  {string_hi.dmidi set parser guitar_string_hi}
                  {string_low.dmidi set parser guitar_string_low}
                  {handle (zBassOffset.drv enter)}
               }
               {do
                  {string01.string set parser ''}
                  {string02.string set parser ''}
                  {string03.string set parser ''}
                  {string04.string set parser ''}
                  {string05.string set parser ''}
                  {string06.string set parser ''}
                  {guitar.lookat set parser ''}
                  {set [clip_flags] kValidBass}
                  {set [parser] bassist_parser}
                  {fret.dmidi set parser bass_fret}
                  {strum.dmidi set parser bass_strum}
                  {face_accent.dmidi set parser bass_face_accent}
                  {fret.ikmidi set parser bass_fret_pos}
                  {singalong.weight set parser bass_singalong_parser}
                  {handle (zBassOffset.drv play offset)}
                  {string_hi.dmidi set parser bass_string_hi}
                  {string_low.dmidi set parser bass_string_low}
               }
            }
            ; Start loading our world clips
            {if {exists char_cache}
               {$this world_configure_driver main.drv ""}
            }
         )

         :
         Set
         the
         clips
         that
         we
         have
         loaded.
         (set_world_clips {$this world_set_driver main.drv ""})

         ; Preps for multievent, clearing out loaders from the currently loaded clips.
         (prep_multi_event {$this prep_multi_driver main.drv ""})

         ; called when we go into that event.         
         (enter_multi_event {$this enter_multi_driver main.drv ""})

         CHAR_COMMON
      )

      (drum
         (clip_flags 0)
         (start_group sit)
         (pose_group sit_pose)
         (parser drummer_parser)

         (enter
            CHAR_ENTER_COMMON
            {if {$this exists drumset.grp}
               ; Char in a subdir, so have to do this, grr.
               {if $world
                  {if {$world exists drumset.env}
                     {drumset.grp set environ {$world find drumset.env}}
                  }
                  {right_hand.dmidi play ready}
                  {left_hand.dmidi play ready}
               }
               ; Hide the drumset group when in shell.
               {drumset.grp set_showing {! [in_shell]}}
            }
            ; The instrument maker still needs an event to set these...
            {if {$this exists sticks.grp}
               {sticks.grp set
                  draw_only
                  {if_else [in_shell]
                     doublestick.grp
                     singlestick.grp
                  }
               }
            }
         )

         (enable_player
            {foreach $thing DRUM_THINGS
               {{$thing get parser} add_sink $thing}
            }
            {set [playing] TRUE}
            {$this change_play [cur_play]}
         )

         (disable_player
            {foreach $thing DRUM_THINGS
               {{$thing get parser} remove_sink $thing}
            }
            {set [playing] FALSE}
            {$this change_play [cur_play]}
         )

         ; Called once we know track and venue, to set the instrument.
         (load_instrument
            ($track_type)
            {OutfitLoader.outfit select
               drum
               {{char_cache find_char_data $this} selected_outfit drum}
            }
            {OutfitLoader.outfit start_load TRUE}
         )

         (pre_meta_configure
            PRE_META_CONFIGURE_COMMON
            ; clear out the additive clips.
            {main_add.drv set_clips ''}
         )

         (meta_configure META_CONFIGURE_COMMON)

         (world_configure
            ($t)

            {set [in_shell] FALSE}
            {$this set_blink_song}
            ; Start loading our world clips
            {if {exists char_cache}
               {$this world_configure_driver main.drv ""}
               {$this world_configure_driver main_add.drv "_play"}
            }
         )

         :
         Set
         the
         clips
         that
         we
         have
         loaded.
         (set_world_clips
            {$this world_set_driver main.drv ""}
            {$this world_set_driver main_add.drv "_play"}
         )

         ; Preps for multievent, clearing out loaders from the currently loaded clips.
         (prep_multi_event
            {$this prep_multi_driver main.drv ""}
            {$this prep_multi_driver main_add.drv "_play"}
         )

         ; called when we go into that event.         
         (enter_multi_event
            {$this enter_multi_driver main.drv ""}
            {$this enter_multi_driver main_add.drv "_play"}
         )

         CHAR_COMMON
      )

      (vocal
         (clip_flags 0)
         (start_group stand)
         (pose_group stand_pose)
         (parser vocal_parser)

         (enable_player
            {set [playing] TRUE}
            {$this change_play [cur_play]}
         )

         (disable_player
            {set [playing] FALSE}
            {$this change_play [cur_play]}
         )

         (set_instrument
            ($inst)
            {hands.grp set
               draw_only
               {switch $inst
                  (cowbell cowbell.grp)
                  (tambourine tambourine.grp)
                  (mic mic.grp)
                  (clap empty.grp) ;nothing, just hands.
               }
            }
         )
         (enter
            CHAR_ENTER_COMMON
            ; during precache we don't even have a body so don't set this.
            {unless {&& $edit_mode $cache_mode}
               {$this set_instrument mic}
            }
         )
         (load_instrument
            ($track_type)
            {OutfitLoader.outfit select
               mic
               {{char_cache find_char_data $this} selected_outfit mic}
            }
            {OutfitLoader.outfit start_load TRUE}
         )

         (pre_meta_configure PRE_META_CONFIGURE_COMMON)

         (meta_configure META_CONFIGURE_COMMON)

         (load_face_song
            {do
               ($song {game get_song})
               ($songpath
                  {if_else $song
                     {sprint {song_mgr song_path $song} ".voc"}
                     ""
                  }
               )
               {$this iterate
                  FaceFxLipSyncServo
                  $servo
                  {$servo set_song $songpath TRUE}
               }
            }
         )

         ; asynchronously load the song.
         (world_configure
            ($track_type)

            {set [in_shell] FALSE}
            {$this load_face_song}

            ; Start loading our world clips, if in game.
            {if {exists char_cache}
               {$this world_configure_driver main.drv ""}
            }
         )

         :
         Set
         the
         clips
         that
         we
         have
         loaded.
         (set_world_clips {$this world_set_driver main.drv ""})

         ; Preps for multievent, clearing out loaders from the currently loaded clips.
         (prep_multi_event
            {$this load_face_song}
            {$this prep_multi_driver main.drv ""}
         )

         ; called when we go into that event.         
         (enter_multi_event {$this enter_multi_driver main.drv ""})

         CHAR_COMMON
      )
   )
)

#define CharPart_None (0x001)
#define CharPart_FullBody (0x002)
#define CharPart_Hair (0x004)
#define CharPart_Head (0x008)
#define CharPart_Torso (0x010)
#define CharPart_Hands (0x020)
#define CharPart_Pants (0x040)
#define CharPart_Shoes (0x080)
#define CharPart_LeftLowerArm (0x100)
#define CharPart_RightLowerArm (0x200)
#define CharPart_Neck (0x400)

(Character
   (types
      (eq
         (enter
            {if {exists main.drv}
               {main.drv play still}
            }
         )
      )
      (light_target
         (editor
            (base_anim symbol (list {$this get_clip_names}))
            (base_amplitude
               float
               (range 0 1)
               (help "physical scale of animation loop")
            )
            (base_speed float (help "speed multiplier"))
            (base_phase
               float
               (range 0 1)
               (help "0 to 1, 0.5 would start the loop half way through")
            )
            (add_anim symbol (list {$this get_clip_names}))
            (add_amplitude
               float
               (range 0 1)
               (help "physical scale of animation loop")
            )
            (add_speed float (help "speed multiplier"))
            (add_phase
               float
               (range 0 1)
               (help "0 to 1, 0.5 would start the loop half way through")
            )
            (test script (script {$this test_anim}))
         )
         (base_anim '')
         (base_amplitude 1)
         (base_speed 1)
         (base_phase 0)
         (add_anim '')
         (add_amplitude 0.5)
         (add_speed 1)
         (add_phase 0)

         (get_clip_names
            {set $clips {main.drv get clips_ptr}}
            {set $clipnames {array 0}}
            {$clips iterate
               CharClip
               $i
               {insert_elem $clipnames 0 {$i name}}
            }
            $clipnames
         )

         (test_anim
            {$this play_anim
               [base_anim]
               [base_amplitude]
               [base_speed]
               [base_phase]
               [add_anim]
               [add_amplitude]
               [add_speed]
               [add_phase]
            }
         )

         (play_anim
            ($base_anim
               $base_amp
               $base_speed
               $base_phase
               $add_anim
               $add_amp
               $add_speed
               $add_phase
            )
            ; set blend weights on pos drivers
            {base_pos.drv set weight $base_amp}
            {target_pos.drv set weight $add_amp}

            ; set animation speed
            {main.drv set beat_scale $base_speed}
            {base_pos.drv set beat_scale $base_speed}
            {base_rot.drv set beat_scale $add_speed}
            {target_pos.drv set beat_scale $add_speed}

            ; play animations on all the drivers
            {base_pos_still.drv play still {| kPlayNoBlend kPlayGraphLoop}} ; still drivers always play
            {target_pos_still.drv play still {| kPlayNoBlend kPlayGraphLoop}}
            {main.drv play $base_anim {| kPlayNoBlend kPlayGraphLoop}} ; controls first rot
            {base_pos.drv play $base_anim {| kPlayNoBlend kPlayGraphLoop}} ; controls first pos
            {base_rot.drv play $add_anim {| kPlayNoBlend kPlayGraphLoop}} ; controls second rot
            {target_pos.drv play $add_anim {| kPlayNoBlend kPlayGraphLoop}} ; controls second pos

            ; set offsets
            {set $clip {main.drv first_clip}}
            {set $offset {* {$clip get length} $base_phase}}
            {main.drv offset $offset $offset}
            {set $clip {base_pos.drv first_clip}}
            {set $offset {* {$clip get length} $base_phase}}
            {base_pos.drv offset $offset $offset}
            {set $clip {base_rot.drv first_clip}}
            {set $offset {* {$clip get length} $add_phase}}
            {base_rot.drv offset $offset $offset}
            {set $clip {target_pos.drv first_clip}}
            {set $offset {* {$clip get length} $add_phase}}
            {target_pos.drv offset $offset $offset}
         )
      )

      (clothing_obj
         (editor
            (mat1
               (indent
                  (target
                     object
                     (class Mat)
                     (post_sync {$this update})
                  )
                  (diffuse_tex
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (two_color bool (post_sync {$this update}))
                  (two_color_mask
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (custom_diffuse_tex
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (emissive_map
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (environ_map
                     object
                     (class CubeTex)
                     (post_sync {$this update})
                  )
                  (normal_map
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (specular_map
                     object
                     (class Tex)
                     (post_sync {$this update})
                     (refresh specular_rgb)
                  )
                  (specular_power float (post_sync {$this update}))
                  (specular_rgb color (post_sync {$this update}))
                  (fleck_shaded bool (post_sync {$this update}))
                  (substrate_depth float (post_sync {$this update}))
                  (substrate_color color (post_sync {$this update}))
                  (fleck_shaded_mask
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (norm_detail_map
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (norm_detail_strength float (post_sync {$this update}))
                  (norm_detail_tiling float (post_sync {$this update}))
               )
            )
            (mat2
               (indent
                  (target2
                     object
                     (class Mat)
                     (post_sync {$this update})
                  )
                  (diffuse_tex2
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (two_color2 bool (post_sync {$this update}))
                  (two_color_mask2
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (custom_diffuse_tex2
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (emissive_map2
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (environ_map2
                     object
                     (class CubeTex)
                     (post_sync {$this update})
                  )
                  (normal_map2
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (specular_map2
                     object
                     (class Tex)
                     (post_sync {$this update})
                     (refresh specular_rgb2)
                  )
                  (specular_power2 float (post_sync {$this update}))
                  (specular_rgb2 color (post_sync {$this update}))
                  (fleck_shaded2 bool (post_sync {$this update}))
                  (substrate_depth2 float (post_sync {$this update}))
                  (substrate_color2 color (post_sync {$this update}))
                  (fleck_shaded_mask2
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (norm_detail_map2
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (norm_detail_strength2 float (post_sync {$this update}))
                  (norm_detail_tiling2 float (post_sync {$this update}))
               )
            )
            (mat3
               (indent
                  (target3
                     object
                     (class Mat)
                     (post_sync {$this update})
                  )
                  (diffuse_tex3
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (two_color3 bool (post_sync {$this update}))
                  (two_color_mask3
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (custom_diffuse_tex3
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (emissive_map3
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (environ_map3
                     object
                     (class CubeTex)
                     (post_sync {$this update})
                  )
                  (normal_map3
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (specular_map3
                     object
                     (class Tex)
                     (post_sync {$this update})
                     (refresh specular_rgb2)
                  )
                  (specular_power3 float (post_sync {$this update}))
                  (specular_rgb3 color (post_sync {$this update}))
                  (fleck_shaded3 bool (post_sync {$this update}))
                  (substrate_depth3 float (post_sync {$this update}))
                  (substrate_color3 color (post_sync {$this update}))
                  (fleck_shaded_mask3
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
               )
            )
            (mat4
               (indent
                  (target4
                     object
                     (class Mat)
                     (post_sync {$this update})
                  )
                  (diffuse_tex4
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (two_color4 bool (post_sync {$this update}))
                  (two_color_mask4
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (custom_diffuse_tex4
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (emissive_map4
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (environ_map4
                     object
                     (class CubeTex)
                     (post_sync {$this update})
                  )
                  (normal_map4
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
                  (specular_map4
                     object
                     (class Tex)
                     (post_sync {$this update})
                     (refresh specular_rgb2)
                  )
                  (specular_power4 float (post_sync {$this update}))
                  (specular_rgb4 color (post_sync {$this update}))
                  (fleck_shaded4 bool (post_sync {$this update}))
                  (substrate_depth4 float (post_sync {$this update}))
                  (substrate_color4 color (post_sync {$this update}))
                  (fleck_shaded_mask4
                     object
                     (class Tex)
                     (post_sync {$this update})
                  )
               )
            )
         )
         (target "")
         (diffuse_tex "")
         (custom_diffuse_tex "")
         (emissive_map "")
         (environ_map "")
         (normal_map "")
         (specular_map "")
         (specular_power 30)
         (specular_rgb 0)
         (two_color 1)
         (target2 "")
         (diffuse_tex2 "")
         (custom_diffuse_tex2 "")
         (emissive_map2 "")
         (environ_map2 "")
         (normal_map2 "")
         (specular_map2 "")
         (specular_power2 30)
         (target3 "")
         (diffuse_tex3 "")
         (custom_diffuse_tex3 "")
         (emissive_map3 "")
         (environ_map3 "")
         (normal_map3 "")
         (specular_map3 "")
         (specular_power3 30)
         (specular_rgb2 0)
         (specular_rgb3 0)
         (two_color2 1)
         (two_color3 1)
         (two_color_mask "")
         (two_color_mask2 "")
         (two_color_mask3 "")
         (spec_map_cache "")
         (spec_map_cache2 "")
         (spec_map_cache3 "")
         (fleck_shaded 0)
         (fleck_shaded2 0)
         (fleck_shaded3 0)
         (target4 "")
         (diffuse_tex4 "")
         (custom_diffuse_tex4 "")
         (emissive_map4 "")
         (environ_map4 "")
         (normal_map4 "")
         (specular_map4 "")
         (specular_power4 30)
         (specular_rgb4 0)
         (two_color4 1)
         (two_color_mask4 "")
         (spec_map_cache4 "")
         (fleck_shaded4 0)
         (substrate_depth 1)
         (substrate_color 1)
         (fleck_shaded_mask "")
         (substrate_depth2 1)
         (substrate_color2 1)
         (fleck_shaded_mask2 "")
         (substrate_depth3 1)
         (substrate_color3 1)
         (fleck_shaded_mask3 "")
         (substrate_depth4 1)
         (substrate_color4 1)
         (fleck_shaded_mask4 "")
         (norm_detail_map "")
         (norm_detail_strength 10.0)
         (norm_detail_tiling 10.0)
         (norm_detail_map2 "")
         (norm_detail_strength2 10.0)
         (norm_detail_tiling2 10.0)

         (enter
            {if $edit_mode
               {set [spec_map_cache] [specular_map]}
               {set [spec_map_cache2] [specular_map2]}
               {set [spec_map_cache3] [specular_map3]}
               {set [spec_map_cache4] [specular_map4]}
            }
            {$this update}
         )
         (update
            {if $edit_mode
               {if {&& {! [spec_map_cache]} [specular_map]}
                  {set [specular_rgb]
                     {pack_color 1 1 1}
                  }
               }
               {if {&& {! [spec_map_cache2]} [specular_map2]}
                  {set [specular_rgb2]
                     {pack_color 1 1 1}
                  }
               }
               {if {&& {! [spec_map_cache3]} [specular_map3]}
                  {set [specular_rgb3]
                     {pack_color 1 1 1}
                  }
               }
               {if {&& {! [spec_map_cache4]} [specular_map4]}
                  {set [specular_rgb4]
                     {pack_color 1 1 1}
                  }
               }
               {set [spec_map_cache] [specular_map]}
               {set [spec_map_cache2] [specular_map2]}
               {set [spec_map_cache3] [specular_map3]}
               {set [spec_map_cache4] [specular_map4]}
            }
            {if [target]
               {[target] set diffuse_tex [diffuse_tex]}
               {[target] set custom_diffuse_tex [custom_diffuse_tex]}
               {[target] set emissive_map [emissive_map]}
               {[target] set environ_map [environ_map]}
               {[target] set normal_map [normal_map]}
               {[target] set specular_map [specular_map]}
               {[target] set two_color_mask [two_color_mask]}
               {[target] set specular_power [specular_power]}
               {[target] set specular_rgb [specular_rgb]}
               {[target] set two_color [two_color]}
               {[target] set fleck_shaded [fleck_shaded]}
               {[target] set substrate_depth [substrate_depth]}
               {[target] set substrate_color [substrate_color]}
               {[target] set fleck_shaded_mask [fleck_shaded_mask]}
               {[target] set norm_detail_map [norm_detail_map]}
               {[target] set norm_detail_strength [norm_detail_strength]}
               {[target] set norm_detail_tiling [norm_detail_tiling]}
            }
            {if [target2]
               {[target2] set diffuse_tex [diffuse_tex2]}
               {[target2] set custom_diffuse_tex [custom_diffuse_tex2]}
               {[target2] set emissive_map [emissive_map2]}
               {[target2] set environ_map [environ_map2]}
               {[target2] set normal_map [normal_map2]}
               {[target2] set specular_map [specular_map2]}
               {[target2] set two_color_mask [two_color_mask2]}
               {[target2] set specular_power [specular_power2]}
               {[target2] set specular_rgb [specular_rgb2]}
               {[target2] set two_color [two_color2]}
               {[target2] set fleck_shaded [fleck_shaded2]}
               {[target2] set substrate_depth [substrate_depth2]}
               {[target2] set substrate_color [substrate_color2]}
               {[target2] set fleck_shaded_mask [fleck_shaded_mask2]}
               {[target2] set norm_detail_map [norm_detail_map2]}
               {[target2] set norm_detail_strength [norm_detail_strength2]}
               {[target2] set norm_detail_tiling [norm_detail_tiling2]}
            }
            {if [target3]
               {[target3] set diffuse_tex [diffuse_tex3]}
               {[target3] set custom_diffuse_tex [custom_diffuse_tex3]}
               {[target3] set emissive_map [emissive_map3]}
               {[target3] set environ_map [environ_map3]}
               {[target3] set normal_map [normal_map3]}
               {[target3] set specular_map [specular_map3]}
               {[target3] set two_color_mask [two_color_mask3]}
               {[target3] set specular_power [specular_power3]}
               {[target3] set specular_rgb [specular_rgb3]}
               {[target3] set two_color [two_color3]}
               {[target3] set fleck_shaded [fleck_shaded3]}
               {[target3] set substrate_depth [substrate_depth3]}
               {[target3] set substrate_color [substrate_color3]}
               {[target3] set fleck_shaded_mask [fleck_shaded_mask3]}
            }
            {if [target4]
               {[target4] set diffuse_tex [diffuse_tex4]}
               {[target4] set custom_diffuse_tex [custom_diffuse_tex4]}
               {[target4] set emissive_map [emissive_map4]}
               {[target4] set environ_map [environ_map4]}
               {[target4] set normal_map [normal_map4]}
               {[target4] set specular_map [specular_map4]}
               {[target4] set two_color_mask [two_color_mask4]}
               {[target4] set specular_power [specular_power4]}
               {[target4] set specular_rgb [specular_rgb4]}
               {[target4] set two_color [two_color4]}
               {[target4] set fleck_shaded [fleck_shaded4]}
               {[target4] set substrate_depth [substrate_depth4]}
               {[target4] set substrate_color [substrate_color4]}
               {[target4] set fleck_shaded_mask [fleck_shaded_mask4]}
            }
         )
      )
      (crowd
         ; for future expansion.
      )
   )
)

(PatchRenderer
   (allowed_dirs RndDir)
   ; app should set this
   (test_patch "test_patch.milo")
)