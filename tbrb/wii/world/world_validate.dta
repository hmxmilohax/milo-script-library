#define STD_VALIDATE_FLAGS (
   (min_time 0)
   (max_time 0)
   (platform_only {$this platform_filter})
)
#define WORLD_OBJECT_VALIDATE (
   (test_light_preset "")
   (custom_start_trigger '')
   (next_preset
      ($obj)
      {do
         ($found {== $obj ""})
         ($next "")
         ($preset_names ())
         {resize $preset_names 0}
         {$this iterate
            LightPreset
            $preset
            {insert_elem $preset_names 0 {$preset name}}
         }
         {sort $preset_names}
         {foreach_int $i 0 {size $preset_names}
            {if {== $next ""}
               {if_else $found
                  {set $next {elem $preset_names $i}}
                  {if {== {$obj name} {elem $preset_names $i}}
                     {set $found TRUE}
                  }
               }
            }
         }
         {if_else {== $next ""}
            $next
            {$this find $next}
         }
      }
   )
   (start_test_preset
      {if {!= "" [test_light_preset]}
         {if {exists test_light_preset_anim}
            {delete test_light_preset_anim}
         }
         {[test_light_preset] animate
            (name test_light_preset_anim)
            (loop 0 {[test_light_preset] end_frame})
         }
         {if {exists test_light_preset_task}
            {delete test_light_preset_task}
         }
         {if {[test_light_preset] get manual}
            {[test_light_preset] reset_events}
            {[test_light_preset] first}
            {thread_task kTaskBeats
               (preserve)
               (name test_light_preset_task)
               (script
                  {[test_light_preset] next}
                  {$task sleep 4}
                  {$task loop}
               )
            }
         }
      }
   )
   (validate_light_presets
      {$this iterate
         LightPreset
         $light
         {do
            ($num_entries {$light size (spotlight_entries)})
            {foreach_int $j 0 $num_entries
               {do
                  ($subpart {$light get (spotlight_entries $j subpart)})
                  {if {has_substr $subpart "exo"}
                     {notify
                        {path_name $light}
                        " spotlight_entry "
                        $j
                        " targets subpart "
                        $subpart
                        " which is not safe"
                     }
                  }
               }
            }
         }
      }
   )
   (validate_cameras
      {set $cameras.validating TRUE}
      {$this iterate_self
         BandCamShot
         $shot
         {$this generic_bandcamshot_tests $shot}
         {if {!= {$shot get_type} proj9}
            {notify {path_name $shot} " is not type proj9!"}
         }
         {if {== {$shot get category} TEST_CAM}
            {notify
               {path_name $shot}
               " is category TEST_CAM, please delete or make into a real camera."
            }
         }
         {do
            ($flags {$shot get flags})
            ($count 0)
            {foreach $facing P9_CAMERA_FACINGS
               {if {& {macro_elem $facing} $flags}
                  {'++' $count}
               }
            }
            {if {!= $count 1}
               {notify {path_name $shot} " must have exactly 1 facing set"}
            }
            {if {== {& $flags kP9AllConfigurations} 0}
               {notify
                  {path_name $shot}
                  " must have some waypoint configuration flags set or won't be used"
               }
            }
            {if {== {& $flags kP9DreamAllConfigs} 0}
               {notify
                  {path_name $shot}
                  " must have some dreamscape configuration flags set or won't be used"
               }
            }
         }
         {do
            ($next_shots {$shot list_all_next_shots})
            {foreach_int $i 0 {size $next_shots}
               {set $next {elem $next_shots $i}}
               {foreach_int $i 0 {$next size (targets)}
                  {unless {$next get (targets $i teleport)}
                     {foreach_int $j 0 {$shot size (targets)}
                        {if
                           {&&
                              {== {$next get (targets $i target)} {$shot get (targets $j target)}}
                              {$shot get (targets $j return)}
                           }
                           {notify
                              {path_name $next}
                              " target "
                              {$next get (targets $i target)}
                              " does not teleport, and is a next shot of "
                              $shot
                              " which has return true which will mess up the shot, return should be false"
                           }
                        }
                     }
                  }
               }
               {if {&& {== {$shot get category} INTRO_VENUE} {== $i {- {size $next_shots} 1}}}
                  {if {!= {$next get category} INTRO_OVER}
                     {notify
                        {path_name $next}
                        " is a last shot of "
                        $shot
                        ", must be INTRO_OVER or no lipsync will play"
                     }
                  }
               }
            }
         }
         {if {$shot get postprocess}
            {do
               ($cat {$shot get category})
               {unless
                  {'||'
                     {has_substr $cat INTRO}
                     {has_substr $cat WIN}
                     {has_substr $cat LOSE}
                     {has_substr $cat OUTRO_VENUE}
                     {has_substr $cat OUTRO_FINALE}
                     {has_substr $cat NEXT_SHOT}
                  }
                  {notify {path_name $shot} " category " $cat " has postprocess set"}
               }
            }
         }
         {do
            ($cat {$shot get category})
            {if
               {find_elem
                  (INTRO_VENUE INTRO_OVER LOSE WIN OUTRO_MULTI)
                  $cat
               }
               {if {!= {$shot get rate} k30_fps}
                  {notify {path_name $shot} " category " $cat " must have units of seconds"}
               }
            }
         }
         {if {== {$shot duration} 0}
            {notify {path_name $shot} " has zero duration!"}
         }
      }
      {if {has_substr {path_name $this} "greenscreen.milo"}
         {foreach $cat (DC_LYRIC_CAM_CATS)
            {do
               ($cam FALSE)
               {$this iterate
                  BandCamShot
                  $shot
                  {if {== {$shot get category} $cat}
                     {set $cam TRUE}
                  }
               }
               {if {! $cam}
                  {notify
                     "Camera category "
                     $cat
                     " (for lyrics in venues) not used in any camshot in "
                     {path_name $this}
                  }
               }
            }
         }
      }
      {unless {has_substr {path_name $this} "blank.milo"}
         {do
            ($err {sprint {path_name $this} " no CamShot:"})
            ($camera.cfgs {p9_path_to_configs {path_name $this}})
            ($camera.cats {array (REQUIRED_CAM_CATS)})
            {foreach $cat
               {cond
                  ({has_substr
                        {path_name $this}
                        "abbeyroad01"}
                     (LOSE OUTRO_MULTI)
                  )
                  ({has_substr
                        {path_name $this}
                        "dreamscape"}
                     ()
                  )
                  ({has_substr
                        {path_name $this}
                        "rooftop"}
                     (INTRO_VENUE INTRO_OVER OUTRO_MULTI OUTRO_VENUE OUTRO_FINALE WIN)
                  )
                  {eval
                     (INTRO_VENUE INTRO_OVER OUTRO_MULTI OUTRO_VENUE WIN)
                  }
               }
               {push_back $camera.cats $cat}
            }
            {$this check_categories $err}
         }
      }
      {set $cameras.validating FALSE}
   )
   (check_categories
      ($err)
      {do
         ($err2 "")
         ($found FALSE)
         {foreach $check.cat $camera.cats
            {if_else
               {$this check_waypoint_cfgs
                  {sprint $err " " $check.cat}
               }
               {set $found TRUE}
               {append_str
                  $err2
                  {if_else $err2
                     {sprint "+" $check.cat}
                     $check.cat
                  }
               }
            }
         }
         {if {&& $err2 $found}
            {notify $err " " $err2}
         }
         $found
      }
   )
   (check_waypoint_cfgs
      ($err)
      {do
         ($err2 "")
         ($found FALSE)
         {foreach $check.cfg $camera.cfgs
            {if_else
               {$this check_facings
                  {sprint $err " " $check.cfg}
               }
               {set $found TRUE}
               {append_str
                  $err2
                  {if_else $err2
                     {sprint "|" $check.cfg}
                     $check.cfg
                  }
               }
            }
         }
         {if {&& $err2 $found}
            {notify $err " " $err2}
         }
         $found
      }
   )
   (check_facings
      ($err)
      {do
         ($err2 "")
         ($found FALSE)
         {foreach $check.facing
            {if_else
               {find_elem
                  (INTRO_VENUE INTRO_OVER LOSE OUTRO_VENUE OUTRO_FINALE OUTRO_MULTI WIN)
                  $check.cat
               }
               ("kP9CamAllFacings")
               ("kP9CamLeft" "kP9CamRight")
            }
            {if_else
               {$this check_dream_cfgs
                  {sprint $err " " $check.facing}
               }
               {set $found TRUE}
               {append_str
                  $err2
                  {if_else $err2
                     {sprint "|" $check.facing}
                     $check.facing
                  }
               }
            }
         }
         {if {&& $err2 $found}
            {notify $err " " $err2}
         }
         $found
      }
   )
   (check_dream_cfgs
      ($err)
      {do
         ($err2 "")
         ($found FALSE)
         {foreach $check.dream_cfg
            {if_else {has_substr {path_name $this} "dreamscape"}
               P9_DREAM_CONFIGS
               ("kP9DreamAllConfigs")
            }
            {if_else
               {$this check_platforms
                  {sprint $err " " $check.dream_cfg}
               }
               {set $found TRUE}
               {append_str
                  $err2
                  {if_else $err2
                     {sprint "|" $check.dream_cfg}
                     $check.dream_cfg
                  }
               }
            }
         }
         {if {&& $err2 $found}
            {notify $err " " $err2}
         }
         $found
      }
   )
   (check_platforms
      ($err)
      {do
         ($err2 "")
         ($found FALSE)
         {foreach $check.platform_name ("kPlatformXBox" "kPlatformPS3")
            {if_else
               {$this check_camera
                  {sprint $err " " $check.platform_name}
               }
               {set $found TRUE}
               {append_str
                  $err2
                  {if_else $err2
                     {sprint "|" $check.platform_name}
                     $check.platform_name
                  }
               }
            }
         }
         {if {&& $err2 $found}
            {notify $err " " $err2}
         }
         $found
      }
   )
   (check_camera
      ($err)
      {do
         ($cameras.platform {macro_elem $check.platform_name})
         {if_else
            {&&
               {== $check.cfg "kP9RingoSolo"}
               {find_elem
                  (GJP_NEAR
                     JP_NEAR
                     GP_NEAR
                     GJ_NEAR
                     P_NEAR
                     J_NEAR
                     G_NEAR
                     R_CLOSEUP_HAND
                     P_CLOSEUP_HAND
                     J_CLOSEUP_HAND
                     G_CLOSEUP_HAND
                     P_CLOSEUP_HEAD
                     J_CLOSEUP_HEAD
                     G_CLOSEUP_HEAD
                  )
                  $check.cat
               }
            }
            TRUE
            {$this find_shot
               $check.cat
               (STD_VALIDATE_FLAGS
                  (flags_any {macro_elem $check.cfg})
                  (flags_any {macro_elem $check.facing})
                  (flags_any {macro_elem $check.dream_cfg})
               )
            }
         }
      }
   )
   (platform_filter
      {if_else {== $cameras.platform kPlatformXBox}
         (kPlatformXBox kPlatformNone)
         (kPlatformPS3 kPlatformNone)
      }
   )
   (generic_bandcamshot_tests
      ($shot)
      {do
         ($num {$shot size (targets)})
         {foreach_int $i 0 {- $num 1}
            {do
               ($target {$shot get (targets $i target)})
               {if {!= $target ''}
                  {foreach_int $j {'+' $i 1} $num
                     {if {== $target {$shot get (targets $j target)}}
                        {notify {path_name $shot} " has duplicate target " $target}
                     }
                  }
               }
            }
         }
      }
      {foreach_int $i 0 {$shot size (next_shots)}
         {set $next {$shot get (next_shots $i)}}
         {if {!= {$shot get platform_only} {$next get platform_only}}
            {notify
               {path_name $next}
               " is a next shot of "
               $shot
               " but has different platform_only flags.  They must match."
            }
         }
      }
      {foreach_int $i 0 {$shot size (keyframes)}
         {do
            ($m {$shot get (keyframes $i focus_blur_multiplier)})
            ($has_target FALSE)
            {foreach_int $j 0 {$shot size (keyframes $i targets)}
               {if_else
                  {==
                     ""
                     {$shot get
                        (keyframes $i targets $j entity)
                     }
                  }
                  {notify {path_name $shot} " keyframe " $i " target " $j " is NULL"}
                  {set $has_target TRUE}
               }
            }
            {if
               {!=
                  ""
                  {$shot get
                     (keyframes $i focal_target entity)
                  }
               }
               {set $has_target TRUE}
            }
            {if {&& {== {$shot get use_depth_of_field} TRUE} {! $has_target} {< $m 2}}
               {notify
                  {path_name $shot}
                  " has depth of field enabled, but keyframe "
                  $i
                  " has no valid focal targets and multiplier "
                  $m
                  " < 2, blur will be too close to camera"
               }
            }
         }
      }
   )
)